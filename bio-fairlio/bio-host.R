#
#  A script to post-process and do batch graphing for block IO results
#  generated by bio-host.R
# 
#  Run example:
#
#  1. Rscript bio-host.R single.lun some.csv
#  2. Rscript bio-host.R single.host some.csv
# 
#  Revision History:
#  09.16.2012   Initial writeup 
#
library(plyr)
library(ggplot2)
#source("commons.R")

# block IO for single host single LUN output
single_lun <- function(file) {
    cat("Processing: ", file, "\n")
    df=read.csv(file, strip.white=TRUE)
    if (names(df)[1] == "X.io.mode") {
        names(df)[1] = "io.mode"
        cat("X.io.mode --> io.mode\n")
    }
    iomode =  levels(factor(df$io.mode))
    df$block.size = factor(as.integer(df$block.size/1024))
    
    vmode = list(rand_rd='random read', rand_wr='random write',
                 seq_rd='sequential read', seq_wr='sequential write')
    
    for (m in iomode) {
        cat("io.mode =", m, "\n")
        df.io = subset(df, m == df$io.mode)

        # compute min and max 
        ymin=ceilingEx(as.integer(min(df.io$max)))
        ymax=ceilingEx(as.integer(max(df.io$max)))
        
        quartz(type="pdf", file=paste("bio-single-lun","-",m,".pdf",sep=""))
        theme_set(theme_bw(base_family="Lucida Grande", base_size=16))
        #theme_set(theme_bw(base_family="Lucida Grande", base_size=18))
        g = qplot(block.size, max, 
                data=df.io, 
                shape=factor(queue.size), 
                color=factor(queue.size),
                geom=c("point", "line"),
                group=queue.size,
                ylab="Max (MB/s)\n", 
                xlab="\nBlock size (KB)",
                main=paste("", vmode[m], sep=""))
        g = g + scale_shape_discrete(name="Queue Depth")
        g = g + scale_color_discrete(name="Queue Depth")
        g = g + geom_point(size=3)
        g = g + theme(legend.position="top")
        g = g + scale_y_continuous(
            breaks=as.integer(seq(ymin,ymax, (ymax-ymin)/10)))
        
        print(g)
        dev.off()
    } # end of io mode
}


# command line: "single.host"
# Handle host output, exercising all LUNs
# access scalability vs. # of LUNs
# assuming max is calculated
# right now, the block size is fixed at 1M.


single_host <- function(file) {
    cat("Processing: ", file, "\n")
    df.max=read.csv(file, strip.white=TRUE)
    iomode =  levels(factor(df.max$io.mode))
    cat("Found iomode: ", iomode, "\n")
    df.max$block.size = factor(as.integer(df.max$block.size/1024))
    
    for (m  in iomode) {
        cat("io.mode =", m, "\n")
        df.max.io = subset(df.max, 
            m == df.max$io.mode & df.max$block.size==1024)
        # compute min and max 
        ymin=as.integer(min(df.max.io$max))
        ymax=as.integer(max(df.max.io$max))
        cat("ymin=", ymin, ", ymax=", ymax, "\n")
        quartz(type="pdf", file=paste("bio-single-host","-",m,".pdf",sep=""))
        theme_set(theme_gray(base_family="Lucida Grande"))
        g = qplot(num.devices, max, 
                data=df.max.io, 
                shape=factor(queue.size), 
                color=factor(queue.size),
                geom=c("point", "line"),
                group=queue.size,
                ylab="Max (MB/s)", 
                xlab="Num of devices",
                main=paste("Single Host Scale-Up, block size = 1M, io.mode=",m, sep=""))
        g = g + scale_shape_discrete(name="Queue Depth")
        g = g + scale_color_discrete(name="Queue Depth")
        g = g + geom_point(size=3)
        g = g + opts(legend.position="top")
        g = g + scale_y_continuous(
          breaks=as.integer(seq(ymin,ymax, (ymax-ymin)/10)))
        
        
        print(g)
        dev.off()
    } # end of io mode
}

args = commandArgs(trailingOnly = TRUE)
options(warn=-1)
for (file in args[-1])  {
    if (args[1] == "single.lun") {
        single_lun(file)
    } else if (args[1] == "single.host") {
        single_host(file)
    } else {
        cat("Unknown operations: ", args[1])
    }   
}

